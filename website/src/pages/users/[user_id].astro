---
import BaseLayout from '../../layouts/BaseLayout.astro';

export async function getStaticPaths() {
  // Import dynasty and chopped data
  const dynastyData = await import('../../../public/data/user_lineups_dynasty.json');
  const choppedData = await import('../../../public/data/user_lineups_chopped.json');
  
  const dynastyUsers = dynastyData.default?.users || dynastyData.users || [];
  const choppedUsers = choppedData.default?.users || choppedData.users || [];
  
  const paths = [];
  
  // Create paths for dynasty users
  dynastyUsers.forEach(user => {
    paths.push({
      params: { 
        user_id: `dynasty-${user.user_id}` 
      },
      props: { 
        user: user,
        league: 'Dynasty',
        current_week: dynastyData.default?.current_week || dynastyData.current_week || 15
      }
    });
  });
  
  // Create paths for chopped users
  choppedUsers.forEach(user => {
    paths.push({
      params: { 
        user_id: `chopped-${user.user_id}` 
      },
      props: { 
        user: user,
        league: 'Chopped',
        current_week: choppedData.default?.current_week || choppedData.current_week || 15
      }
    });
  });
  
  return paths;
}

const { user, league, current_week } = Astro.props;

// Helper function to check if a player is available to play this week
function isPlayerAvailable(player) {
  // Exclude players with injury statuses that mean they won't play
  const unavailableStatuses = ['Out', 'IR', 'Doubtful', 'Suspended'];
  if (player.injury_status && unavailableStatuses.includes(player.injury_status)) {
    return false;
  }
  
  // Exclude players on bye week (opponent is 'BYE')
  if (player.opponent === 'BYE') {
    return false;
  }
  
  return true;
}

// Group players by position
const qbs = user.players.filter(p => p.position === 'QB');
const rbs = user.players.filter(p => p.position === 'RB');
const wrs = user.players.filter(p => p.position === 'WR');
const tes = user.players.filter(p => p.position === 'TE');
const flex = [...rbs, ...wrs, ...tes];
const kickers = user.players.filter(p => p.position === 'K');

// League-specific roster settings
const isDynasty = league === 'Dynasty';
const rosterSettings = isDynasty ? {
  qb: 1,
  rb: 2,
  wr: 3,
  te: 1,
  flex: 1,
  superflex: 1,
  k: 0
} : {
  qb: 1,
  rb: 2,
  wr: 2,
  te: 1,
  flex: 1,
  superflex: 0,
  k: 0
};

// Calculate recommended starters based on league settings
// Use average of projected points and season average when projection available
// Only recommend players who are available to play this week
function getRecommendedStarters(players, count) {
  return [...players]
    .filter(p => isPlayerAvailable(p)) // Only include available players
    .sort((a, b) => {
      // Average projection with season average if projection exists and > 0
      const aScore = (a.projected_points && a.projected_points > 0) 
        ? (a.projected_points + a.avg_ppg) / 2 
        : a.avg_ppg;
      const bScore = (b.projected_points && b.projected_points > 0) 
        ? (b.projected_points + b.avg_ppg) / 2 
        : b.avg_ppg;
      return bScore - aScore;
    })
    .slice(0, count);
}

const recommendedQB = getRecommendedStarters(qbs, rosterSettings.qb);
const recommendedRB = getRecommendedStarters(rbs, rosterSettings.rb);
const recommendedWR = getRecommendedStarters(wrs, rosterSettings.wr);
const recommendedTE = getRecommendedStarters(tes, rosterSettings.te);
const usedPlayers = [...recommendedQB, ...recommendedRB, ...recommendedWR, ...recommendedTE];
const recommendedFlex = getRecommendedStarters(
  flex.filter(p => !usedPlayers.includes(p)),
  rosterSettings.flex
);
const recommendedSuperflex = rosterSettings.superflex > 0 ? getRecommendedStarters(
  [...qbs, ...rbs, ...wrs, ...tes].filter(p => !usedPlayers.includes(p) && !recommendedFlex.includes(p)),
  rosterSettings.superflex
) : [];
const recommendedK = rosterSettings.k > 0 ? getRecommendedStarters(kickers, rosterSettings.k) : [];

const recommendedLineup = [
  ...recommendedQB,
  ...recommendedRB,
  ...recommendedWR,
  ...recommendedTE,
  ...recommendedFlex,
  ...recommendedSuperflex,
  ...recommendedK
];

// Calculate total projected points for recommended lineup using averaged scores
const totalProjectedPoints = recommendedLineup.reduce((sum, player) => {
  const score = (player.projected_points && player.projected_points > 0) 
    ? (player.projected_points + player.avg_ppg) / 2 
    : player.avg_ppg;
  return sum + score;
}, 0);
---

<BaseLayout title={`${user.user_name} - Week ${current_week} Lineup Advisor`}>
  <script is:inline src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  
  <div class="page-header">
    <a href={league === 'Dynasty' ? '/season-stats-dynasty' : '/season-stats-chopped'} class="back-link">
      ‚Üê Back to {league} Stats
    </a>
    <h1>üèà {user.user_name}'s Lineup</h1>
    <p>Week {current_week} Matchup Advisor - {league} League</p>
  </div>

  <div class="container">
    <!-- Recommended Lineup -->
    <section class="recommended-section">
      <h2>üí° Recommended Starters (Week {current_week})</h2>
      <p class="section-subtitle">Based on projected points and season averages<br class="mobile-break" /><span class="projected-total">Projected Total: <strong style="color: #4CAF50; font-size: 1.2em;">{totalProjectedPoints.toFixed(1)}</strong> pts</span></p>
      
      <div class="recommended-grid">
        {recommendedLineup.map(player => {
          const proj = player.projected_points || 0;
          const hasProjection = proj > 0;
          const diff = hasProjection ? proj - player.avg_ppg : 0;
          return (
          <a href={`/players/${player.player_id}`} class="recommended-card">
            <div class="position-badge {player.position.toLowerCase()}">{player.position}</div>
            {player.injury_status && (
              <div class="injury-badge" title={player.injury_notes || ''}>
                {player.injury_status}
              </div>
            )}
            <div class="player-info">
              <div class="player-name">{player.player_name}</div>
              <div class="player-team">{player.team} vs {player.opponent}</div>
            </div>
            <div class="player-stats">
              <div class="stat-item">
                <span class="stat-label">Avg</span>
                <span class="stat-value">{player.avg_ppg.toFixed(1)}</span>
              </div>
              <div class="stat-item" style={{borderLeft: '2px solid #4CAF50', paddingLeft: '8px'}}>
                <span class="stat-label">Proj</span>
                <span class="stat-value" style={{fontWeight: 'bold', color: hasProjection ? (diff > 2 ? '#4CAF50' : diff < -2 ? '#f44336' : '#fff') : '#999'}}>
                  {hasProjection ? proj.toFixed(1) : player.avg_ppg.toFixed(1)}
                </span>
              </div>
              <div class="stat-item">
                <span class="stat-label">Opp</span>
                <span class="stat-value">{player.opp_avg_allowed.toFixed(1)}</span>
              </div>
              <div class="stat-item">
                <span class="stat-label">Trend</span>
                <span class="stat-value" style={{color: player.trend_dir === '‚ñ≤' ? 'green' : (player.trend_dir === '‚ñº' ? 'red' : 'gray')}}>
                  {player.trend_dir}
                </span>
              </div>
            </div>
          </a>
        )})}
      </div>
    </section>

    <!-- Position Scatter Plots -->
    <section class="charts-section">
      <h2>üìä Matchup Analysis by Position</h2>
      <p class="section-subtitle">Player Average vs Opponent Average Allowed - Hover for player names</p>
      
      <div class="charts-grid-2x2">
        <div class="chart-card">
          <h3>Quarterbacks</h3>
          <canvas id="qbChart"></canvas>
        </div>
        <div class="chart-card">
          <h3>Running Backs</h3>
          <canvas id="rbChart"></canvas>
        </div>
        <div class="chart-card">
          <h3>Wide Receivers</h3>
          <canvas id="wrChart"></canvas>
        </div>
        <div class="chart-card">
          <h3>Tight Ends</h3>
          <canvas id="teChart"></canvas>
        </div>
      </div>
    </section>

    <!-- Full Roster Tables -->
    <section class="roster-section">
      <h2>üìã Full Roster Stats</h2>
      
      {qbs.length > 0 && (
        <div class="position-table">
          <h3>Quarterbacks</h3>
          <table>
            <thead>
              <tr>
                <th>Player</th>
                <th>Status</th>
                <th>Team</th>
                <th>Week {current_week} Opp</th>
                <th>Avg PPG</th>
                <th>Projected</th>
                <th>Opp Avg</th>
                <th>Trend</th>
                <th>Consistency</th>
              </tr>
            </thead>
            <tbody>
              {qbs.map(player => {
                const proj = player.projected_points || 0;
                const diff = proj - player.avg_ppg;
                const diffIndicator = Math.abs(diff) < 1 ? '' : (diff > 0 ? '‚Üë' : '‚Üì');
                return (
                <tr>
                  <td><a href={`/players/${player.player_id}`}>{player.player_name}</a></td>
                  <td>
                    {player.injury_status ? (
                      <span class="injury-tag" title={player.injury_notes || ''}>{player.injury_status}</span>
                    ) : (
                      <span style="color: #4CAF50;">‚úì</span>
                    )}
                  </td>
                  <td>{player.team}</td>
                  <td>{player.opponent}</td>
                  <td style="font-weight: bold;">{player.avg_ppg.toFixed(1)}</td>
                  <td style={{fontWeight: 'bold', color: diff > 2 ? 'green' : (diff < -2 ? 'red' : 'inherit')}}>
                    {proj > 0 ? proj.toFixed(1) : '-'} {diffIndicator}
                  </td>
                  <td>{player.opp_avg_allowed.toFixed(1)}</td>
                  <td style={{color: player.trend_dir === '‚ñ≤' ? 'green' : (player.trend_dir === '‚ñº' ? 'red' : 'inherit')}}>
                    {player.trend_dir} {player.trend_pct.toFixed(0)}%
                  </td>
                  <td>{player.consistency.toFixed(2)}</td>
                </tr>
              )})}
            </tbody>
          </table>
        </div>
      )}

      {rbs.length > 0 && (
        <div class="position-table">
          <h3>Running Backs</h3>
          <table>
            <thead>
              <tr>
                <th>Player</th>
                <th>Status</th>
                <th>Team</th>
                <th>Week {current_week} Opp</th>
                <th>Avg PPG</th>
                <th>Projected</th>
                <th>Opp Avg</th>
                <th>Trend</th>
                <th>Consistency</th>
              </tr>
            </thead>
            <tbody>
              {rbs.map(player => {
                const proj = player.projected_points || 0;
                const diff = proj - player.avg_ppg;
                const diffIndicator = Math.abs(diff) < 1 ? '' : (diff > 0 ? '‚Üë' : '‚Üì');
                return (
                <tr>
                  <td><a href={`/players/${player.player_id}`}>{player.player_name}</a></td>
                  <td>
                    {player.injury_status ? (
                      <span class="injury-tag" title={player.injury_notes || ''}>{player.injury_status}</span>
                    ) : (
                      <span style="color: #4CAF50;">‚úì</span>
                    )}
                  </td>
                  <td>{player.team}</td>
                  <td>{player.opponent}</td>
                  <td style="font-weight: bold;">{player.avg_ppg.toFixed(1)}</td>
                  <td style={{fontWeight: 'bold', color: diff > 2 ? 'green' : (diff < -2 ? 'red' : 'inherit')}}>
                    {proj > 0 ? proj.toFixed(1) : '-'} {diffIndicator}
                  </td>
                  <td>{player.opp_avg_allowed.toFixed(1)}</td>
                  <td style={{color: player.trend_dir === '‚ñ≤' ? 'green' : (player.trend_dir === '‚ñº' ? 'red' : 'inherit')}}>
                    {player.trend_dir} {player.trend_pct.toFixed(0)}%
                  </td>
                  <td>{player.consistency.toFixed(2)}</td>
                </tr>
              )})}
            </tbody>
          </table>
        </div>
      )}

      {wrs.length > 0 && (
        <div class="position-table">
          <h3>Wide Receivers</h3>
          <table>
            <thead>
              <tr>
                <th>Player</th>
                <th>Status</th>
                <th>Team</th>
                <th>Week {current_week} Opp</th>
                <th>Avg PPG</th>
                <th>Projected</th>
                <th>Opp Avg</th>
                <th>Trend</th>
                <th>Consistency</th>
              </tr>
            </thead>
            <tbody>
              {wrs.map(player => {
                const proj = player.projected_points || 0;
                const diff = proj - player.avg_ppg;
                const diffIndicator = Math.abs(diff) < 1 ? '' : (diff > 0 ? '‚Üë' : '‚Üì');
                return (
                <tr>
                  <td><a href={`/players/${player.player_id}`}>{player.player_name}</a></td>
                  <td>
                    {player.injury_status ? (
                      <span class="injury-tag" title={player.injury_notes || ''}>{player.injury_status}</span>
                    ) : (
                      <span style="color: #4CAF50;">‚úì</span>
                    )}
                  </td>
                  <td>{player.team}</td>
                  <td>{player.opponent}</td>
                  <td style="font-weight: bold;">{player.avg_ppg.toFixed(1)}</td>
                  <td style={{fontWeight: 'bold', color: diff > 2 ? 'green' : (diff < -2 ? 'red' : 'inherit')}}>
                    {proj > 0 ? proj.toFixed(1) : '-'} {diffIndicator}
                  </td>
                  <td>{player.opp_avg_allowed.toFixed(1)}</td>
                  <td style={{color: player.trend_dir === '‚ñ≤' ? 'green' : (player.trend_dir === '‚ñº' ? 'red' : 'inherit')}}>
                    {player.trend_dir} {player.trend_pct.toFixed(0)}%
                  </td>
                  <td>{player.consistency.toFixed(2)}</td>
                </tr>
              )})}
            </tbody>
          </table>
        </div>
      )}

      {tes.length > 0 && (
        <div class="position-table">
          <h3>Tight Ends</h3>
          <table>
            <thead>
              <tr>
                <th>Player</th>
                <th>Status</th>
                <th>Team</th>
                <th>Week {current_week} Opp</th>
                <th>Avg PPG</th>
                <th>Projected</th>
                <th>Opp Avg</th>
                <th>Trend</th>
                <th>Consistency</th>
              </tr>
            </thead>
            <tbody>
              {tes.map(player => {
                const proj = player.projected_points || 0;
                const diff = proj - player.avg_ppg;
                const diffIndicator = Math.abs(diff) < 1 ? '' : (diff > 0 ? '‚Üë' : '‚Üì');
                return (
                <tr>
                  <td><a href={`/players/${player.player_id}`}>{player.player_name}</a></td>
                  <td>
                    {player.injury_status ? (
                      <span class="injury-tag" title={player.injury_notes || ''}>{player.injury_status}</span>
                    ) : (
                      <span style="color: #4CAF50;">‚úì</span>
                    )}
                  </td>
                  <td>{player.team}</td>
                  <td>{player.opponent}</td>
                  <td style="font-weight: bold;">{player.avg_ppg.toFixed(1)}</td>
                  <td style={{fontWeight: 'bold', color: diff > 2 ? 'green' : (diff < -2 ? 'red' : 'inherit')}}>
                    {proj > 0 ? proj.toFixed(1) : '-'} {diffIndicator}
                  </td>
                  <td>{player.opp_avg_allowed.toFixed(1)}</td>
                  <td style={{color: player.trend_dir === '‚ñ≤' ? 'green' : (player.trend_dir === '‚ñº' ? 'red' : 'inherit')}}>
                    {player.trend_dir} {player.trend_pct.toFixed(0)}%
                  </td>
                  <td>{player.consistency.toFixed(2)}</td>
                </tr>
              )})}
            </tbody>
          </table>
        </div>
      )}

      {kickers.length > 0 && (
        <div class="position-table">
          <h3>Kickers</h3>
          <table>
            <thead>
              <tr>
                <th>Player</th>
                <th>Team</th>
                <th>Week {current_week} Opp</th>
                <th>Avg PPG</th>
                <th>Trend</th>
                <th>Consistency</th>
              </tr>
            </thead>
            <tbody>
              {kickers.map(player => (
                <tr>
                  <td><a href={`/players/${player.player_id}`}>{player.player_name}</a></td>
                  <td>{player.team}</td>
                  <td>{player.opponent}</td>
                  <td style="font-weight: bold;">{player.avg_ppg.toFixed(1)}</td>
                  <td style={{color: player.trend_dir === '‚ñ≤' ? 'green' : (player.trend_dir === '‚ñº' ? 'red' : 'inherit')}}>
                    {player.trend_dir} {player.trend_pct.toFixed(0)}%
                  </td>
                  <td>{player.consistency.toFixed(2)}</td>
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      )}
    </section>
  </div>

  <script define:vars={{ qbs, rbs, wrs, tes }}>
    // Position benchmark values - using same value for both axes to create quadrants
    const positionBenchmarks = {
      QB: 19.3,
      RB: 15.3,
      WR: 14.8,
      TE: 11.2
    };

    // Generate distinct colors for players
    const colors = [
      '#667eea', '#f59e0b', '#10b981', '#ef4444', '#8b5cf6',
      '#ec4899', '#14b8a6', '#f97316', '#6366f1', '#84cc16'
    ];

    function createScatterChart(canvasId, players, positionName) {
      const ctx = document.getElementById(canvasId);
      if (!ctx) return;

      // Assign each player a unique color and create dataset
      // FLIPPED: x = player avg, y = opponent avg
      const datasets = players.map((p, index) => ({
        label: p.player_name,
        data: [{
          x: p.avg_ppg,
          y: p.opp_avg_allowed,
          player: p.player_name
        }],
        backgroundColor: colors[index % colors.length],
        borderColor: colors[index % colors.length],
        borderWidth: 2,
        pointRadius: 10,
        pointHoverRadius: 12
      }));

      // Calculate max values for axis scaling
      const maxOppAvg = Math.max(...players.map(p => p.opp_avg_allowed), 10);
      const maxPlayerAvg = Math.max(...players.map(p => p.avg_ppg), 10);
      const axisMax = Math.max(maxOppAvg, maxPlayerAvg) * 1.1;

      const benchmark = positionBenchmarks[positionName];

      // Create a custom plugin for reference lines
      const referenceLinePlugin = {
        id: 'referenceLines',
        afterDatasetsDraw(chart) {
          const { ctx, chartArea: { left, right, top, bottom }, scales: { x, y } } = chart;
          
          const xPos = x.getPixelForValue(benchmark);
          const yPos = y.getPixelForValue(benchmark);
          
          ctx.save();
          
          // Vertical line
          ctx.beginPath();
          ctx.setLineDash([10, 5]);
          ctx.strokeStyle = 'rgba(107, 114, 128, 0.7)';
          ctx.lineWidth = 2;
          ctx.moveTo(xPos, top);
          ctx.lineTo(xPos, bottom);
          ctx.stroke();
          
          // Horizontal line
          ctx.beginPath();
          ctx.setLineDash([10, 5]);
          ctx.strokeStyle = 'rgba(107, 114, 128, 0.7)';
          ctx.lineWidth = 2;
          ctx.moveTo(left, yPos);
          ctx.lineTo(right, yPos);
          ctx.stroke();
          
          ctx.restore();
        }
      };

      new Chart(ctx, {
        type: 'scatter',
        data: { datasets },
        plugins: [referenceLinePlugin],
        options: {
          responsive: true,
          maintainAspectRatio: true,
          aspectRatio: 1,
          plugins: {
            tooltip: {
              callbacks: {
                title: function(context) {
                  return context[0].raw.player;
                },
                label: function(context) {
                  const point = context.raw;
                  const diff = point.y - point.x;
                  let matchupText = '';
                  if (diff > 3) {
                    matchupText = 'Favorable Matchup ‚úì';
                  } else if (diff < -3) {
                    matchupText = 'Tough Matchup ‚úó';
                  } else {
                    matchupText = 'Average Matchup';
                  }
                  return [
                    `Player Avg: ${point.x.toFixed(1)} pts`,
                    `Opp Avg Allowed: ${point.y.toFixed(1)} pts`,
                    matchupText
                  ];
                }
              }
            },
            legend: {
              display: true,
              position: 'bottom',
              labels: {
                boxWidth: 10,
                font: { size: 10 },
                padding: 8
              }
            }
          },
          scales: {
            x: {
              title: {
                display: true,
                text: 'Player Avg Points Per Game',
                font: { size: 13, weight: 'bold' }
              },
              min: 0,
              max: axisMax,
              ticks: {
                callback: function(value) {
                  return value.toFixed(0);
                }
              }
            },
            y: {
              title: {
                display: true,
                text: 'Opponent Avg Points Allowed',
                font: { size: 13, weight: 'bold' }
              },
              min: 0,
              max: axisMax,
              ticks: {
                callback: function(value) {
                  return value.toFixed(0);
                }
              }
            }
          }
        }
      });
    }

    // Initialize charts
    if (qbs.length > 0) createScatterChart('qbChart', qbs, 'QB');
    if (rbs.length > 0) createScatterChart('rbChart', rbs, 'RB');
    if (wrs.length > 0) createScatterChart('wrChart', wrs, 'WR');
    if (tes.length > 0) createScatterChart('teChart', tes, 'TE');
  </script>

  <style>
    .container {
      max-width: 1400px;
      margin: 0 auto;
      padding: 20px;
    }

    .page-header {
      text-align: center;
      margin-bottom: 40px;
      padding: 30px 20px;
      background: white;
      border-radius: 15px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
    }

    .page-header h1 {
      font-size: 2.5em;
      color: #2d3748;
      margin: 10px 0;
    }

    .page-header p {
      color: #718096;
      font-size: 1.1em;
    }

    .back-link {
      display: inline-block;
      color: #667eea;
      text-decoration: none;
      font-weight: 600;
      margin-bottom: 10px;
      transition: all 0.3s;
    }

    .back-link:hover {
      color: #5568d3;
      transform: translateX(-5px);
    }

    .section-subtitle {
      color: #718096;
      margin-top: 5px;
      margin-bottom: 20px;
    }

    /* Recommended Lineup Section */
    .recommended-section {
      background: white;
      padding: 30px;
      border-radius: 15px;
      margin-bottom: 30px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
    }

    .recommended-section h2 {
      color: #667eea;
      margin-bottom: 10px;
    }

    .recommended-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
      gap: 15px;
      margin-top: 20px;
    }

    .recommended-card {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 15px;
      border-radius: 10px;
      text-decoration: none;
      transition: all 0.3s;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .recommended-card:hover {
      transform: translateY(-5px);
      box-shadow: 0 8px 20px rgba(102, 126, 234, 0.4);
    }

    .position-badge {
      display: inline-block;
      padding: 4px 8px;
      border-radius: 5px;
      font-size: 0.8em;
      font-weight: bold;
      background: rgba(255, 255, 255, 0.2);
      width: fit-content;
    }

    .injury-badge {
      position: absolute;
      top: 10px;
      right: 10px;
      padding: 3px 8px;
      border-radius: 4px;
      font-size: 0.7em;
      font-weight: bold;
      background: #f44336;
      color: white;
      cursor: help;
    }

    .injury-tag {
      display: inline-block;
      padding: 2px 6px;
      border-radius: 3px;
      font-size: 0.85em;
      font-weight: bold;
      background: #ffebee;
      color: #c62828;
      cursor: help;
    }

    .recommended-card {
      position: relative;
    }

    .player-info {
      flex: 1;
    }

    .player-name {
      font-weight: bold;
      font-size: 1.1em;
    }

    .player-team {
      font-size: 0.9em;
      opacity: 0.9;
      margin-top: 5px;
    }

    .player-stats {
      display: flex;
      gap: 10px;
      padding-top: 10px;
      border-top: 1px solid rgba(255, 255, 255, 0.2);
    }

    .stat-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      flex: 1;
    }

    .stat-label {
      font-size: 0.7em;
      opacity: 0.8;
    }

    .stat-value {
      font-weight: bold;
      font-size: 1.1em;
    }

    /* Charts Section */
    .charts-section {
      background: white;
      padding: 30px;
      border-radius: 15px;
      margin-bottom: 30px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
    }

    .charts-section h2 {
      color: #667eea;
      margin-bottom: 10px;
    }

    .charts-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
      gap: 30px;
      margin-top: 20px;
    }

    .charts-grid-2x2 {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 30px;
      margin-top: 20px;
    }

    .charts-grid-2x2 .chart-card {
      min-height: 500px;
    }

    .charts-grid-2x2 canvas {
      max-height: 450px;
    }

    .chart-card {
      background: #f7fafc;
      padding: 20px;
      border-radius: 10px;
    }

    .chart-card h3 {
      color: #2d3748;
      margin-bottom: 15px;
      text-align: center;
    }

    /* Roster Tables */
    .roster-section {
      background: white;
      padding: 30px;
      border-radius: 15px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
    }

    .roster-section h2 {
      color: #667eea;
      margin-bottom: 30px;
    }

    .position-table {
      margin-bottom: 40px;
    }

    .position-table h3 {
      color: #2d3748;
      margin-bottom: 15px;
      padding-bottom: 10px;
      border-bottom: 2px solid #667eea;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      background: white;
    }

    thead {
      background: #f7fafc;
    }

    th {
      padding: 12px;
      text-align: left;
      font-weight: 600;
      color: #2d3748;
      border-bottom: 2px solid #e2e8f0;
    }

    td {
      padding: 12px;
      border-bottom: 1px solid #e2e8f0;
      color: #4a5568;
    }

    tbody tr:hover {
      background: #f7fafc;
    }

    td a {
      color: #667eea;
      text-decoration: none;
      font-weight: 600;
    }

    td a:hover {
      text-decoration: underline;
    }

    @media (max-width: 768px) {
      .container {
        padding: 10px;
      }

      .page-header {
        padding: 20px 15px;
      }

      .page-header h1 {
        font-size: 1.8em;
      }

      .page-header p {
        font-size: 0.95em;
      }

      .recommended-section,
      .charts-section,
      .roster-section {
        padding: 20px 15px;
      }

      .section-subtitle {
        font-size: 0.9em;
      }

      .recommended-grid {
        grid-template-columns: 1fr;
        gap: 12px;
      }

      .recommended-card {
        padding: 12px;
      }

      .player-name {
        font-size: 1em;
      }

      .player-stats {
        gap: 8px;
      }

      .stat-label {
        font-size: 0.65em;
      }

      .stat-value {
        font-size: 0.95em;
      }

      .charts-grid,
      .charts-grid-2x2 {
        grid-template-columns: 1fr;
        gap: 20px;
      }

      .charts-grid-2x2 .chart-card {
        min-height: 350px;
      }

      .charts-grid-2x2 canvas {
        max-height: 300px;
      }

      .chart-card {
        padding: 15px;
      }

      .chart-card h3 {
        font-size: 1em;
        margin-bottom: 10px;
      }

      /* Make tables scrollable on mobile */
      .position-table {
        overflow-x: auto;
        -webkit-overflow-scrolling: touch;
      }

      table {
        min-width: 600px;
        font-size: 0.85em;
      }

      th, td {
        padding: 8px 6px;
        white-space: nowrap;
      }

      th {
        font-size: 0.8em;
      }

      td a {
        display: block;
        max-width: 120px;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .injury-tag {
        font-size: 0.75em;
        padding: 1px 4px;
      }

      .injury-badge {
        padding: 2px 6px;
        font-size: 0.65em;
      }

      .mobile-break {
        display: block;
        margin: 5px 0;
      }

      .projected-total {
        display: block;
        margin-top: 8px;
      }
    }

    @media (min-width: 769px) {
      .mobile-break {
        display: none;
      }
    }

    /* Additional mobile improvements for very small screens */
    @media (max-width: 480px) {
      .page-header h1 {
        font-size: 1.5em;
      }

      .recommended-section h2,
      .charts-section h2,
      .roster-section h2 {
        font-size: 1.3em;
      }

      .recommended-card {
        padding: 10px;
      }

      .position-badge {
        font-size: 0.7em;
        padding: 3px 6px;
      }

      .player-stats {
        flex-wrap: wrap;
        gap: 6px;
      }

      .stat-item {
        min-width: 45%;
      }

      table {
        font-size: 0.75em;
      }

      th, td {
        padding: 6px 4px;
      }
    }
  </style>

  <!-- Chart.js -->
  <script is:inline src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
</BaseLayout>
